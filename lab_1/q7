/*******************************************************************************/

#include <stdio.h>
#include "simlib.h"

/*******************************************************************************/

/*
 * Simulation Parameters
 */

#define RANDOM_SEED 5259140
#define NUMBER_TO_SERVE 50e6

#define SERVICE_TIME 1
#define ARRIVAL_RATE 0.1

#define BLIP_RATE 10000
#define MAX_QUEUE_SIZE 1000

/*******************************************************************************/

/*
 * main() uses various simulation parameters and creates a clock variable to
 * simulate real time. A loop repeatedly determines if the next event to occur
 * is a customer arrival or customer departure. In either case the state of the
 * system is updated and statistics are collected before the next
 * iteration. When it finally reaches NUMBER_TO_SERVE customers, the program
 * outputs some statistics such as mean delay.
 */

#define N 1

struct Data
{
    double utilization;
    double fraction_served;
    double mean_number;
    double mean_delay;
    double total_rejected;
    double total_arrived;
};


void simulate(long int number_to_serve, struct Data *res, unsigned random_seed);

int main()
{
    const unsigned random_seed[10] = {};

    printf("length,utilization,fraction_served,mean_number,mean_delay");

    struct Data temp;

    double sum_utilization, sum_fraction_served, sum_mean_number, sum_mean_delay,sum_rejected,sum_arrived;

    for (int i = 0; i < N; i ++) {
        sum_utilization = sum_fraction_served = sum_mean_number = sum_mean_delay = 0;
        sum_rejected = 0;
        sum_arrived = 0;

        for (int j = 0; j < 10; j ++) {
            simulate((i + 1) * 10000, &temp, random_seed[j]);
            sum_utilization += temp.utilization;
            sum_fraction_served += temp.fraction_served;
            sum_mean_number += temp.mean_number;
            sum_mean_delay += temp.mean_delay;
            sum_rejected += temp.total_rejected;
            sum_arrived += temp.total_arrived;
        }

        printf( "\n%d,%f,%f,%f,%f", (i + 1) * 10000, sum_utilization / 10, sum_fraction_served / 10,
                                        sum_mean_number / 10, sum_mean_delay/ 10);
        printf("\nRejected = %f", sum_rejected);
        printf("\nArrived = %f", sum_arrived);
        printf("\nReject Rate = %f\n", sum_rejected/sum_arrived);
    }

    return 0;
}

void simulate(long int number_to_serve, struct Data *res, unsigned random_seed)
{
    double clock = 0;

    int number_in_system = 0;
    double next_arrival_time = 0;
    double next_departure_time = 0;

    long int total_served = 0;
    long int total_arrived = 0;
    long int total_rejected = 0;

    double total_busy_time = 0;
    double integral_of_n = 0;
    double last_event_time = 0;


    random_generator_initialize(random_seed);

    while (total_served < number_to_serve)
    {
        if (number_in_system == 0 || next_arrival_time < next_departure_time)
        {
            clock = next_arrival_time;
            next_arrival_time = clock + exponential_generator((double)1 / ARRIVAL_RATE);

            /* Check the number of service in system, ignore new requests */
            if (number_in_system>=MAX_QUEUE_SIZE){
                total_rejected++;
            }else{
                integral_of_n += number_in_system * (clock - last_event_time);
                last_event_time = clock;

                number_in_system++;

                if (number_in_system == 1)
                    next_departure_time = clock + SERVICE_TIME;
            }
                total_arrived++;
        }
        else
        {
            clock = next_departure_time;

            integral_of_n += number_in_system * (clock - last_event_time);
            last_event_time = clock;

            number_in_system--;
            total_served++;
            total_busy_time += SERVICE_TIME;

            if (number_in_system > 0)
                next_departure_time = clock + SERVICE_TIME;
        }
    }

    res->utilization = total_busy_time / clock;
    res->mean_delay = integral_of_n / total_served;
    res->mean_number = integral_of_n / clock;
    res->fraction_served = (double)total_served / total_arrived;
    res->total_arrived = (double)total_arrived;
    res->total_rejected = (double)total_rejected;
}





